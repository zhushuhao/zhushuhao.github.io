<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>小代码 大世界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="小代码 大世界">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="小代码 大世界">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小代码 大世界">
  
    <link rel="alternate" href="/atom.xml" title="小代码 大世界" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小代码 大世界</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Buscar"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ActivityStarter-startActivityMayWait" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/18/ActivityStarter-startActivityMayWait/" class="article-date">
  <time datetime="2018-01-18T02:49:14.000Z" itemprop="datePublished">2018-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/18/ActivityStarter-startActivityMayWait/">ActivityStarter-startActivityMayWait</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###源码位置com.android.server.am.ActivityStarter.java</p>
<pre><code>class ActivityStarter {}
这个类没有继承别的类，也没有实现任何接口
这个类的定义如下：
/**
 * Controller for interpreting how and then launching activities.
 *
 * This class collects all the logic for determining how an intent and flags should be turned into
 * an activity and associated task and stack.
 */
 解释如何发布活动的控制器。
 这个类收集所有逻辑，以确定如何根据intent和flags转换为一个对应的Activity，并且和堆栈关联在一起。
 大致是个帮助类。
</code></pre><p>  查看startActivityMayWait方法，这是个很长的方法，需要很大的勇气。<br>  先解释一下为什么叫MayWait，因为调用startActivity是可能要等待结果的startActivityForResult，那就要挂起调用者<br>    final int startActivityMayWait(IApplicationThread caller, int callingUid,<br>              String callingPackage, Intent intent, String resolvedType,<br>              IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>              IBinder resultTo, String resultWho, int requestCode, int startFlags,<br>              ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,<br>              Bundle bOptions, boolean ignoreTargetSecurity, int userId,<br>              IActivityContainer iContainer, TaskRecord inTask) {</p>
<pre><code>    // Refuse possible leaked file descriptors
    //拒绝可能泄露的文件描述符
    if (intent != null &amp;&amp; intent.hasFileDescriptors()) {
        throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);
    }
    mSupervisor.mActivityMetricsLogger.notifyActivityLaunching();
    boolean componentSpecified = intent.getComponent() != null;

    // Save a copy in case ephemeral needs it
    //保存一个副本以备临时需要
    final Intent ephemeralIntent = new Intent(intent);
    // Don&apos;t modify the client&apos;s object!
    //不要修改客户端的对象！
    intent = new Intent(intent);

    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);
    if (rInfo == null) {
        UserInfo userInfo = mSupervisor.getUserInfo(userId);
        if (userInfo != null &amp;&amp; userInfo.isManagedProfile()) {
            // Special case for managed profiles, if attempting to launch non-cryto aware
            // app in a locked managed profile from an unlocked parent allow it to resolve
            // as user will be sent via confirm credentials to unlock the profile.
            UserManager userManager = UserManager.get(mService.mContext);
            boolean profileLockedAndParentUnlockingOrUnlocked = false;
            long token = Binder.clearCallingIdentity();
            try {
                UserInfo parent = userManager.getProfileParent(userId);
                profileLockedAndParentUnlockingOrUnlocked = (parent != null)
                        &amp;&amp; userManager.isUserUnlockingOrUnlocked(parent.id)
                        &amp;&amp; !userManager.isUserUnlockingOrUnlocked(userId);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
            if (profileLockedAndParentUnlockingOrUnlocked) {
                rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,
                        PackageManager.MATCH_DIRECT_BOOT_AWARE
                                | PackageManager.MATCH_DIRECT_BOOT_UNAWARE);
            }
        }
    }
    // Collect information about the target of the Intent.
    //收集intent有关的信息
    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);

    ActivityOptions options = ActivityOptions.fromBundle(bOptions);
    ActivityStackSupervisor.ActivityContainer container =
            (ActivityStackSupervisor.ActivityContainer)iContainer;
    synchronized (mService) {
        if (container != null &amp;&amp; container.mParentActivity != null &amp;&amp;
                container.mParentActivity.state != RESUMED) {
            // Cannot start a child activity if the parent is not resumed.
            return ActivityManager.START_CANCELED;
        }
        final int realCallingPid = Binder.getCallingPid();
        final int realCallingUid = Binder.getCallingUid();
        int callingPid;
        if (callingUid &gt;= 0) {
            callingPid = -1;
        } else if (caller == null) {
            callingPid = realCallingPid;
            callingUid = realCallingUid;
        } else {
            callingPid = callingUid = -1;
        }

        final ActivityStack stack;
        if (container == null || container.mStack.isOnHomeDisplay()) {
            stack = mSupervisor.mFocusedStack;
        } else {
            stack = container.mStack;
        }
        stack.mConfigWillChange = config != null &amp;&amp; mService.mConfiguration.diff(config) != 0;
        if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,
                &quot;Starting activity when config will change = &quot; + stack.mConfigWillChange);

        final long origId = Binder.clearCallingIdentity();

        if (aInfo != null &amp;&amp;
                (aInfo.applicationInfo.privateFlags
                        &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) {
            // This may be a heavy-weight process!  Check to see if we already
            // have another, different heavy-weight process running.
            if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) {
                final ProcessRecord heavy = mService.mHeavyWeightProcess;
                if (heavy != null &amp;&amp; (heavy.info.uid != aInfo.applicationInfo.uid
                        || !heavy.processName.equals(aInfo.processName))) {
                    int appCallingUid = callingUid;
                    if (caller != null) {
                        ProcessRecord callerApp = mService.getRecordForAppLocked(caller);
                        if (callerApp != null) {
                            appCallingUid = callerApp.info.uid;
                        } else {
                            Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller
                                    + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;
                                    + intent.toString());
                            ActivityOptions.abort(options);
                            return ActivityManager.START_PERMISSION_DENIED;
                        }
                    }

                    IIntentSender target = mService.getIntentSenderLocked(
                            ActivityManager.INTENT_SENDER_ACTIVITY, &quot;android&quot;,
                            appCallingUid, userId, null, null, 0, new Intent[] { intent },
                            new String[] { resolvedType }, PendingIntent.FLAG_CANCEL_CURRENT
                                    | PendingIntent.FLAG_ONE_SHOT, null);

                    Intent newIntent = new Intent();
                    if (requestCode &gt;= 0) {
                        // Caller is requesting a result.
                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT, true);
                    }
                    newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT,
                            new IntentSender(target));
                    if (heavy.activities.size() &gt; 0) {
                        ActivityRecord hist = heavy.activities.get(0);
                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP,
                                hist.packageName);
                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK,
                                hist.task.taskId);
                    }
                    newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP,
                            aInfo.packageName);
                    newIntent.setFlags(intent.getFlags());
                    newIntent.setClassName(&quot;android&quot;,
                            HeavyWeightSwitcherActivity.class.getName());
                    intent = newIntent;
                    resolvedType = null;
                    caller = null;
                    callingUid = Binder.getCallingUid();
                    callingPid = Binder.getCallingPid();
                    componentSpecified = true;
                    rInfo = mSupervisor.resolveIntent(intent, null /*resolvedType*/, userId);
                    aInfo = rInfo != null ? rInfo.activityInfo : null;
                    if (aInfo != null) {
                        aInfo = mService.getActivityInfoForUser(aInfo, userId);
                    }
                }
            }
        }

        final ActivityRecord[] outRecord = new ActivityRecord[1];

        //重点看这里
        int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,
                aInfo, rInfo, voiceSession, voiceInteractor,
                resultTo, resultWho, requestCode, callingPid,
                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                options, ignoreTargetSecurity, componentSpecified, outRecord, container,
                inTask);

        Binder.restoreCallingIdentity(origId);

        if (stack.mConfigWillChange) {
            // If the caller also wants to switch to a new configuration,
            // do so now.  This allows a clean switch, as we are waiting
            // for the current activity to pause (so we will not destroy
            // it), and have not yet started the next activity.
            mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,
                    &quot;updateConfiguration()&quot;);
            stack.mConfigWillChange = false;
            if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,
                    &quot;Updating to new configuration after starting activity.&quot;);
            mService.updateConfigurationLocked(config, null, false);
        }

        if (outResult != null) {
            outResult.result = res;
            if (res == ActivityManager.START_SUCCESS) {
                mSupervisor.mWaitingActivityLaunched.add(outResult);
                do {
                    try {
                        mService.wait();
                    } catch (InterruptedException e) {
                    }
                } while (outResult.result != START_TASK_TO_FRONT
                        &amp;&amp; !outResult.timeout &amp;&amp; outResult.who == null);
                if (outResult.result == START_TASK_TO_FRONT) {
                    res = START_TASK_TO_FRONT;
                }
            }
            if (res == START_TASK_TO_FRONT) {
                ActivityRecord r = stack.topRunningActivityLocked();
                if (r.nowVisible &amp;&amp; r.state == RESUMED) {
                    outResult.timeout = false;
                    outResult.who = new ComponentName(r.info.packageName, r.info.name);
                    outResult.totalTime = 0;
                    outResult.thisTime = 0;
                } else {
                    outResult.thisTime = SystemClock.uptimeMillis();
                    mSupervisor.mWaitingActivityVisible.add(outResult);
                    do {
                        try {
                            mService.wait();
                        } catch (InterruptedException e) {
                        }
                    } while (!outResult.timeout &amp;&amp; outResult.who == null);
                }
            }
        }

        final ActivityRecord launchedActivity = mReusedActivity != null
                ? mReusedActivity : outRecord[0];
        mSupervisor.mActivityMetricsLogger.notifyActivityLaunched(res, launchedActivity);
        return res;
    }
}
</code></pre><p>  重点</p>
<pre><code>  int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,
                        aInfo, rInfo, voiceSession, voiceInteractor,
                        resultTo, resultWho, requestCode, callingPid,
                        callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                        options, ignoreTargetSecurity, componentSpecified, outRecord, container,
                        inTask);

  转到startActivityLocked方法

  查看startActivityLocked方法
  Locked意思是调用者需要保证加锁保护，不能重复调用，
  在startActivityMayWait中，是采用mService对象，
  也就是构造ActivityStackSupervisor时传进来的ActivityManagerService的对象。

 前面先做一系列检查的工作，比如权限，比如Intent防火墙检查。
 准备做好之后，就new一个ActivityRecord，用于存储Activity的各种状态和历史信息。
 然后，通过getFocusedStack方法获取当前获取焦点的ActivityStack。
 ActivityStackSupervisor中的mFocusedStack中保存了当前的前台ActivityStack。
 下面就准备切换新进程了，先判断一下是否可以切换，如果处于通话中界面等无法马上切换的情况。
 通过ActivityManagerService的checkAppSwitchAllowedLocked方法来做检查，
 如果当前不允许做进程切换，就先存到PendingActivityLaunch的列表中，等待以后有机会再调用。
 如果允许做切换，那么先检查一下当前是否有以前的等待任务，如果有就先执行它们，
 调用doPendingActivityLaunchesLocked方法去执行这个循环。

final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
          String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
          IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
          IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
          String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
          ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
          ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,
          TaskRecord inTask) {
      int err = ActivityManager.START_SUCCESS;

      ProcessRecord callerApp = null;
      if (caller != null) {
          callerApp = mService.getRecordForAppLocked(caller);
          if (callerApp != null) {
              callingPid = callerApp.pid;
              callingUid = callerApp.info.uid;
          } else {
              Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller
                      + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;
                      + intent.toString());
              err = ActivityManager.START_PERMISSION_DENIED;
          }
      }

      final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;

      if (err == ActivityManager.START_SUCCESS) {
          Slog.i(TAG, &quot;START u&quot; + userId + &quot; {&quot; + intent.toShortString(true, true, true, false)
                  + &quot;} from uid &quot; + callingUid
                  + &quot; on display &quot; + (container == null ? (mSupervisor.mFocusedStack == null ?
                  Display.DEFAULT_DISPLAY : mSupervisor.mFocusedStack.mDisplayId) :
                  (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY :
                          container.mActivityDisplay.mDisplayId)));
      }

      ActivityRecord sourceRecord = null;
      ActivityRecord resultRecord = null;
      if (resultTo != null) {
          sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);
          if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,
                  &quot;Will send result to &quot; + resultTo + &quot; &quot; + sourceRecord);
          if (sourceRecord != null) {
              if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) {
                  resultRecord = sourceRecord;
              }
          }
      }

      final int launchFlags = intent.getFlags();

      if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) {
          // Transfer the result target from the source activity to the new
          // one being started, including any failures.
          if (requestCode &gt;= 0) {
              ActivityOptions.abort(options);
              return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
          }
          resultRecord = sourceRecord.resultTo;
          if (resultRecord != null &amp;&amp; !resultRecord.isInStackLocked()) {
              resultRecord = null;
          }
          resultWho = sourceRecord.resultWho;
          requestCode = sourceRecord.requestCode;
          sourceRecord.resultTo = null;
          if (resultRecord != null) {
              resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);
          }
          if (sourceRecord.launchedFromUid == callingUid) {
              // The new activity is being launched from the same uid as the previous
              // activity in the flow, and asking to forward its result back to the
              // previous.  In this case the activity is serving as a trampoline between
              // the two, so we also want to update its launchedFromPackage to be the
              // same as the previous activity.  Note that this is safe, since we know
              // these two packages come from the same uid; the caller could just as
              // well have supplied that same package name itself.  This specifially
              // deals with the case of an intent picker/chooser being launched in the app
              // flow to redirect to an activity picked by the user, where we want the final
              // activity to consider it to have been launched by the previous app activity.
              callingPackage = sourceRecord.launchedFromPackage;
          }
      }

      if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) {
          // We couldn&apos;t find a class that can handle the given Intent.
          // That&apos;s the end of that!
          err = ActivityManager.START_INTENT_NOT_RESOLVED;
      }

      if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) {
          // We couldn&apos;t find the specific class specified in the Intent.
          // Also the end of the line.
          err = ActivityManager.START_CLASS_NOT_FOUND;
      }

      if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null
              &amp;&amp; sourceRecord.task.voiceSession != null) {
          // If this activity is being launched as part of a voice session, we need
          // to ensure that it is safe to do so.  If the upcoming activity will also
          // be part of the voice session, we can only launch it if it has explicitly
          // said it supports the VOICE category, or it is a part of the calling app.
          if ((launchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0
                  &amp;&amp; sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) {
              try {
                  intent.addCategory(Intent.CATEGORY_VOICE);
                  if (!AppGlobals.getPackageManager().activitySupportsIntent(
                          intent.getComponent(), intent, resolvedType)) {
                      Slog.w(TAG,
                              &quot;Activity being started in current voice task does not support voice: &quot;
                                      + intent);
                      err = ActivityManager.START_NOT_VOICE_COMPATIBLE;
                  }
              } catch (RemoteException e) {
                  Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);
                  err = ActivityManager.START_NOT_VOICE_COMPATIBLE;
              }
          }
      }

      if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) {
          // If the caller is starting a new voice session, just make sure the target
          // is actually allowing it to run this way.
          try {
              if (!AppGlobals.getPackageManager().activitySupportsIntent(intent.getComponent(),
                      intent, resolvedType)) {
                  Slog.w(TAG,
                          &quot;Activity being started in new voice task does not support: &quot;
                                  + intent);
                  err = ActivityManager.START_NOT_VOICE_COMPATIBLE;
              }
          } catch (RemoteException e) {
              Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);
              err = ActivityManager.START_NOT_VOICE_COMPATIBLE;
          }
      }

      final ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack;

      if (err != START_SUCCESS) {
          if (resultRecord != null) {
              resultStack.sendActivityResultLocked(
                      -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null);
          }
          ActivityOptions.abort(options);
          return err;
      }

      boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,
              requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity, callerApp,
              resultRecord, resultStack, options);
      abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,
              callingPid, resolvedType, aInfo.applicationInfo);

      if (mService.mController != null) {
          try {
              // The Intent we give to the watcher has the extra data
              // stripped off, since it can contain private information.
              Intent watchIntent = intent.cloneFilter();
              abort |= !mService.mController.activityStarting(watchIntent,
                      aInfo.applicationInfo.packageName);
          } catch (RemoteException e) {
              mService.mController = null;
          }
      }

      mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage);
      mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid, callingUid,
              options);
      intent = mInterceptor.mIntent;
      rInfo = mInterceptor.mRInfo;
      aInfo = mInterceptor.mAInfo;
      resolvedType = mInterceptor.mResolvedType;
      inTask = mInterceptor.mInTask;
      callingPid = mInterceptor.mCallingPid;
      callingUid = mInterceptor.mCallingUid;
      options = mInterceptor.mActivityOptions;
      if (abort) {
          if (resultRecord != null) {
              resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode,
                      RESULT_CANCELED, null);
          }
          // We pretend to the caller that it was really started, but
          // they will just get a cancel result.
          ActivityOptions.abort(options);
          return START_SUCCESS;
      }

      // If permissions need a review before any of the app components can run, we
      // launch the review activity and pass a pending intent to start the activity
      // we are to launching now after the review is completed.
      if (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; aInfo != null) {
          if (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired(
                  aInfo.packageName, userId)) {
              IIntentSender target = mService.getIntentSenderLocked(
                      ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage,
                      callingUid, userId, null, null, 0, new Intent[]{intent},
                      new String[]{resolvedType}, PendingIntent.FLAG_CANCEL_CURRENT
                              | PendingIntent.FLAG_ONE_SHOT, null);

              final int flags = intent.getFlags();
              Intent newIntent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS);
              newIntent.setFlags(flags
                      | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
              newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName);
              newIntent.putExtra(Intent.EXTRA_INTENT, new IntentSender(target));
              if (resultRecord != null) {
                  newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, true);
              }
              intent = newIntent;

              resolvedType = null;
              callingUid = realCallingUid;
              callingPid = realCallingPid;

              rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);
              aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags,
                      null /*profilerInfo*/);

              if (DEBUG_PERMISSIONS_REVIEW) {
                  Slog.i(TAG, &quot;START u&quot; + userId + &quot; {&quot; + intent.toShortString(true, true,
                          true, false) + &quot;} from uid &quot; + callingUid + &quot; on display &quot;
                          + (container == null ? (mSupervisor.mFocusedStack == null ?
                          Display.DEFAULT_DISPLAY : mSupervisor.mFocusedStack.mDisplayId) :
                          (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY :
                                  container.mActivityDisplay.mDisplayId)));
              }
          }
      }

      // If we have an ephemeral app, abort the process of launching the resolved intent.
      // Instead, launch the ephemeral installer. Once the installer is finished, it
      // starts either the intent we resolved here [on install error] or the ephemeral
      // app [on install success].
      if (rInfo != null &amp;&amp; rInfo.ephemeralResolveInfo != null) {
          intent = buildEphemeralInstallerIntent(intent, ephemeralIntent,
                  rInfo.ephemeralResolveInfo.getPackageName(), callingPackage, resolvedType,
                  userId);
          resolvedType = null;
          callingUid = realCallingUid;
          callingPid = realCallingPid;

          aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, null /*profilerInfo*/);
      }

      ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,
              intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,
              requestCode, componentSpecified, voiceSession != null, mSupervisor, container,
              options, sourceRecord);
      if (outActivity != null) {
          outActivity[0] = r;
      }

      if (r.appTimeTracker == null &amp;&amp; sourceRecord != null) {
          // If the caller didn&apos;t specify an explicit time tracker, we want to continue
          // tracking under any it has.
          r.appTimeTracker = sourceRecord.appTimeTracker;
      }

      final ActivityStack stack = mSupervisor.mFocusedStack;
      if (voiceSession == null &amp;&amp; (stack.mResumedActivity == null
              || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) {
          if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,
                  realCallingPid, realCallingUid, &quot;Activity start&quot;)) {
              PendingActivityLaunch pal =  new PendingActivityLaunch(r,
                      sourceRecord, startFlags, stack, callerApp);
              mPendingActivityLaunches.add(pal);
              ActivityOptions.abort(options);
              return ActivityManager.START_SWITCHES_CANCELED;
          }
      }

      if (mService.mDidAppSwitch) {
          // This is the second allowed switch since we stopped switches,
          // so now just generally allow switches.  Use case: user presses
          // home (switches disabled, switch to home, mDidAppSwitch now true);
          // user taps a home icon (coming from home so allowed, we hit here
          // and now allow anyone to switch again).
          mService.mAppSwitchesAllowedTime = 0;
      } else {
          mService.mDidAppSwitch = true;
      }

      doPendingActivityLaunchesLocked(false);

      try {
          mService.mWindowManager.deferSurfaceLayout();
          err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,
                  true, options, inTask);
      } finally {
          mService.mWindowManager.continueSurfaceLayout();
      }
      postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack);
      return err;
  }
</code></pre><p>###参考资料</p>
<p>####<a href="https://yq.aliyun.com/articles/62489" target="_blank" rel="noopener">https://yq.aliyun.com/articles/62489</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/18/ActivityStarter-startActivityMayWait/" data-id="cjcubibt3000lgjs6nzkuiqdt" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ActivityStarter-startActivityMayWait/">ActivityStarter-startActivityMayWait</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ActivityManagerService-startActivity" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/18/ActivityManagerService-startActivity/" class="article-date">
  <time datetime="2018-01-18T02:24:35.000Z" itemprop="datePublished">2018-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/18/ActivityManagerService-startActivity/">ActivityManagerService-startActivity</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###源码位置com.android.server.am.ActivityManagerService.java</p>
<pre><code>public final class ActivityManagerService extends ActivityManagerNative
    implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {}

ActivityManagerService.java继承了ActivityManagerNative,而ActivityManagerNative实现了
IActivityManager的接口
</code></pre><p>查看startActivity方法</p>
<pre><code>//caller 调用的主线程
//callingPackage 包名
//intent
//resolvedType
//resultTo
//resultWho
//requestCode
//startFlags
//profilerInfo
//bOptions

 @Override
     public final int startActivity(IApplicationThread caller, String callingPackage,
             Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
             int startFlags, ProfilerInfo profilerInfo, Bundle options) {
         return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
             resultWho, requestCode, startFlags, profilerInfo, options,
             UserHandle.getCallingUserId());
     }
</code></pre><p>接着调用了startActivityAsUser方法,多传入了一个int类型的userId参数<br>总得来说startActivityAsUser就是做一下调用者的基本权限的检查</p>
<pre><code>@Override
   public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
           Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
           int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {
       //检查调用者是否被隔离，如果被隔离会抛出SecurityException。
       enforceNotIsolatedCaller(&quot;startActivity&quot;);
       //检查调用者是否有权限执行call操作
       userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,
               false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);

       // TODO: Switch to user app stacks here.

       return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,
               resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
               profilerInfo, null, null, options, false, userId, null, null);
   }
</code></pre><p>####SDK23会走这里 接着又调用了ActivityStackSupervisor-startActivityMayWait方法,先走API23这个流程</p>
<p>####SDK25会走这里 接着又调用了ActivityStarter-startActivityMayWait方法，以后再说</p>
<p>###参考资料</p>
<p>####<a href="http://blog.csdn.net/chenkai19920410/article/details/54344295" target="_blank" rel="noopener">http://blog.csdn.net/chenkai19920410/article/details/54344295</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/18/ActivityManagerService-startActivity/" data-id="cjcubibs60003gjs61t50xrqt" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ActivityManagerService-startActivity/">ActivityManagerService-startActivity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ActivityStackSupervisor-startActivityMayWait/">ActivityStackSupervisor-startActivityMayWait</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ActivityStarter-startActivityMayWait/">ActivityStarter-startActivityMayWait</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ActivityManagerNative-getDefault" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/18/ActivityManagerNative-getDefault/" class="article-date">
  <time datetime="2018-01-18T01:53:16.000Z" itemprop="datePublished">2018-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/18/ActivityManagerNative-getDefault/">ActivityManagerNative-getDefault</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>源码位置 </p>
<p>  android.app.ActivityManagerNative.java</p>
<pre><code>public abstract class ActivityManagerNative extends Binder 
implements IActivityManager{}

ActivityManagerNative是一个抽象类,继承了Binder类，实现了IActivityManager接口
ActivityManagerService是它的子类，也就实现了IActivityManager接口，
下面的ActivityManagerProxy类也实现了IActivityManager接口
</code></pre><p>getDefault()方法, 最终得到的是一个ActivityManagerProxy对象</p>
<pre><code>static public IActivityManager getDefault() {
    return gDefault.get();
}
</code></pre><p>查看gDefault</p>
<pre><code>private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() {
        protected IActivityManager create() {

           //获取到ActivityManagerService的Binder
            IBinder b = ServiceManager.getService(&quot;activity&quot;);

            if (false) {
                Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);
            }

            //得到一个ActivityManagerProxy对象
            IActivityManager am = asInterface(b);
            if (false) {
                Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);
            }
            return am;
        }
    };
</code></pre><p>查看asInterface方法,返回了一个ActivityManagerProxy对象</p>
<pre><code>  /**
    * Cast a Binder object into an activity manager interface, generating
    * a proxy if needed.
    * 把一个Binder对象强转为一个activity manger 接口，生成一个代理对象
    */
static public IActivityManager asInterface(IBinder obj) {
       if (obj == null) {
           return null;
       }

        //String descriptor  = &quot;android.app.IActivityManager&quot;;

       IActivityManager in =
           (IActivityManager)obj.queryLocalInterface(descriptor);

       if (in != null) {
           return in;
       }
       //返回了一个ActivityManagerProxy

       return new ActivityManagerProxy(obj);

   }
</code></pre><p>查看queryLocalInterface方法</p>
<pre><code>/**
 * Attempt to retrieve a local implementation of an interface
 * for this Binder object.  If null is returned, you will need
 * to instantiate a proxy class to marshall calls through
 * the transact() method.
 *    尝试为这个binder对象取出一个本地接口实现。如果返回null,你需要通过transaction()实例化一个代理对象
 *    引领调用命令
 *
 */
public IInterface queryLocalInterface(String descriptor);
</code></pre><p>android.os.Binder.java,实现了IBinder接口</p>
<pre><code>/**
  * Use information supplied to attachInterface() to return the
  * associated IInterface if it matches the requested
  * descriptor.
  */
 public IInterface queryLocalInterface(String descriptor) {
     if (mDescriptor.equals(descriptor)) {
         return mOwner;
     }
     return null;
 }
</code></pre><p>查看attachInterface()方法</p>
<pre><code>/**
 * Convenience method for associating a specific interface with the Binder.
 * After calling, queryLocalInterface() will be implemented for you
 * to return the given owner IInterface when the corresponding
 * descriptor is requested.
 这个方法把一个特定的接口和Binder关联在一起。调用这个方法之后，queryLocalInterface() 会被实现，然后当相关的descriptor
 被请求的时候，你就可以把owner IInterface返回给他
 */
public void attachInterface(IInterface owner, String descriptor) {
    mOwner = owner;
    mDescriptor = descriptor;
}
</code></pre><p>最后查看ActivityManagerProxy类,这是ActivityManagerNative的内部类。它实现了IActivityManager接口，<br>通过Binder通信，最终会调用ActivityManagerService里面的类似startActivity等等的方法</p>
<pre><code>class ActivityManagerProxy implements IActivityManager
{
    public ActivityManagerProxy(IBinder remote)
    {
        mRemote = remote;
    }

    public IBinder asBinder()
    {
        return mRemote;
    }

    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,
            String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(caller != null ? caller.asBinder() : null);
        data.writeString(callingPackage);
        intent.writeToParcel(data, 0);
        data.writeString(resolvedType);
        data.writeStrongBinder(resultTo);
        data.writeString(resultWho);
        data.writeInt(requestCode);
        data.writeInt(startFlags);
        if (profilerInfo != null) {
            data.writeInt(1);
            profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
        } else {
            data.writeInt(0);
        }
        if (options != null) {
            data.writeInt(1);
            options.writeToParcel(data, 0);
        } else {
            data.writeInt(0);
        }
        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);
        reply.readException();
        int result = reply.readInt();
        reply.recycle();
        data.recycle();
        return result;
    }

    ...
}
</code></pre><p>###转到ActivityManagerService-startActivity</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/18/ActivityManagerNative-getDefault/" data-id="cjcubibrr0000gjs6qe00blz6" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ActivityManagerNative-getDefault/">ActivityManagerNative-getDefault</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ActivityManagerService-startActivity/">ActivityManagerService-startActivity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Instrumentation-execStartActivity" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/17/Instrumentation-execStartActivity/" class="article-date">
  <time datetime="2018-01-17T10:22:14.000Z" itemprop="datePublished">2018-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/17/Instrumentation-execStartActivity/">Instrumentation.execStartActivity</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Instrumentation这个类，用来做测试。关于这个类，源码是这样介绍的：</p>
<pre><code>/**
 * Base class for implementing application instrumentation code.  When running
 * with instrumentation turned on, this class will be instantiated for you
 * before any of the application code, allowing you to monitor all of the
 * interaction the system has with the application.  An Instrumentation
 * implementation is described to the system through an AndroidManifest.xml&apos;s
 * &amp;lt;instrumentation&amp;gt; tag.
 */

 网上翻译意思大概是这样的：

 用于实现应用程序代码的基类。当使用仪器进行运行时，该类将在任何应用程序代码之前为您实例化，
 允许您监视系统与应用程序之间的所有交互。Instrumentation的实现类在AndroidManifest.xml通过
 &lt;instrumentation&gt;进行声明。

 也就是说系统通过这个方法，给我们监控app的代码执行提供了一个入口。
</code></pre><p>我们来看execStartActivity方法  </p>
<pre><code>/**
* Execute a startActivity call made by the application.  The default 
* implementation takes care of updating any active {@link ActivityMonitor}
* objects and dispatches this call to the system activity manager; you can
* override this to watch for the application to start an activity, and 
* modify what happens when it does. 

执行由应用程序调用的startActivity方法。默认的实现负责更新任何活动对象，
并将此调用发送给系统活动管理器；您可以覆盖此项以监视启动活动的应用程序，
以及修改当它发生时会发生什么。

*
* &lt;p&gt;This method returns an {@link ActivityResult} object, which you can 
* use when intercepting application calls to avoid performing the start 
* activity action but still return the result the application is 
* expecting.  To do this, override this method to catch the call to start 
* activity so that it returns a new ActivityResult containing the results 
* you would like the application to see, and don&apos;t call up to the super 
* class.  Note that an application is only expecting a result if 
* &lt;var&gt;requestCode&lt;/var&gt; is &amp;gt;= 0.
*
这个方法返回一个Activityresult对象.
您可以在拦截应用程序调用时使用它，以避免执行启动活动操作，但仍然返回应用程序期望的结果。
为此，重写此方法以捕捉start activity的调用，它返回一个新的Activityresult,
含有结果你想看到的应用程序,而不调用父类。注意，应用只在requestCode&gt;0时需要一个结果.

* &lt;p&gt;This method throws {@link android.content.ActivityNotFoundException}
* if there was no Activity found to run the given Intent.
*
这个方法如果找不到指定的Activity会抛出android.content.ActivityNotFoundException异常

* @param who The Context from which the activity is being started.
* @param contextThread The main thread of the Context from which the activity
*                      is being started.
* @param token Internal token identifying to the system who is starting 
*              the activity; may be null.
* @param target Which activity is performing the start (and thus receiving 
*               any result); may be null if this call is not being made
*               from an activity.
* @param intent The actual Intent to start.
* @param requestCode Identifier for this request&apos;s result; less than zero 
*                    if the caller is not expecting a result.
* @param options Addition options.
*
* @return To force the return of a particular result, return an 
*         ActivityResult object containing the desired data; otherwise
*         return null.  The default implementation always returns null.
*
* @throws android.content.ActivityNotFoundException
*
* @see Activity#startActivity(Intent)
* @see Activity#startActivityForResult(Intent, int)
* @see Activity#startActivityFromChild
*
* {@hide}
*/

该对象是在ActivityThread创建Activity时创建的，一个应用程序中只有一个Instrumentation对象，
每个Activity内部都有一个该对象的引用。Instrumentation可以理解为应用进程的管家，
ActivityThread要创建或者暂停某个Activity时，是通过这个&quot;管家&quot;进行的，
设置这个管家的好处是可以统计所有的&quot;开销&quot;，开销的信息保存在&quot;管家&quot;那里。
其实正如其名称所示，Instrumentation就是为了&quot;测量&quot;、&quot;统计&quot;，
因为管家掌握了所有的&quot;开销&quot;，自然也就具有了统计的功能。
当然，Instrumentation类和ActivityThread的分工是有本质区别的，
后者就像是这个家里的主人，负责创建这个&quot;家庭&quot;，并负责和外界打交道，比如接收AmS的通知等。
</code></pre><p>   看一下execStartActivity的代码</p>
<pre><code>public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, int requestCode, Bundle options) {
        IApplicationThread whoThread = (IApplicationThread) contextThread;
        Uri referrer = target != null ? target.onProvideReferrer() : null;
        if (referrer != null) {
            intent.putExtra(Intent.EXTRA_REFERRER, referrer);
        }
        if (mActivityMonitors != null) {
            synchronized (mSync) {
                final int N = mActivityMonitors.size();
                for (int i=0; i&lt;N; i++) {
                    final ActivityMonitor am = mActivityMonitors.get(i);
                    if (am.match(who, null, intent)) {
                        am.mHits++;
                        if (am.isBlocking()) {
                            return requestCode &gt;= 0 ? am.getResult() : null;
                        }
                        break;
                    }
                }
            }
        }
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess();
            int result = ActivityManagerNative.getDefault()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
            checkStartActivityResult(result, intent);
        } catch (RemoteException e) {
            throw new RuntimeException(&quot;Failure from system&quot;, e);
        }
        return null;
    }
</code></pre><p>   看这里</p>
<pre><code>int result = ActivityManagerNative.getDefault()
               .startActivity(whoThread, who.getBasePackageName(), intent,
                       intent.resolveTypeIfNeeded(who.getContentResolver()),
                       token, target != null ? target.mEmbeddedID : null,
                       requestCode, 0, null, options);
这里ActivityManagerNative.getDefault()返回了ActivityManagerProxy对象，ActivityManagerProxy通过Binder通信
最终会调用ActivityManagerService.java中的startActivity方法
</code></pre><p>  转到ActivityManagerNative-getDefault</p>
<p>###参考资料</p>
<p>####<a href="https://www.cnblogs.com/itpepe/p/4756328.html" target="_blank" rel="noopener">https://www.cnblogs.com/itpepe/p/4756328.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/17/Instrumentation-execStartActivity/" data-id="cjcubibtd000tgjs64q8125qx" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ActivityManagerNative-getDefault/">ActivityManagerNative-getDefault</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-activity启动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/16/activity启动/" class="article-date">
  <time datetime="2018-01-16T10:43:48.000Z" itemprop="datePublished">2018-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/16/activity启动/">activity启动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#API23</p>
<p>   从第一次调用startActivity开始</p>
<pre><code>startActivity(intent);
startActivity(intent,null);
startActivityForResult(intent,-1);
startActivityForResult(intent,-1,null);

android.app.Instrumentation.java-&gt;execStartActivity()
这里调用了ActivityManagerNative.getDefault().startActivity-&gt;ActivityManagerProxy.startActivity方法
-&gt;通过Binder最终调用ActivityManagerService.startActivity

ActivityManagerService.java-&gt;startActivity()
添加了callingUserId参数，调用ActivityManagerService.startActivityAsUser
ActivityManagerService.java-&gt;startActivityAsUser()
获取了userId,加入了几个参数，调用ActivityStackSupervisor.startActivityMayWait


ActivityStackSupervisor.java-&gt;startActivityMayWait()
方法里面有synchronized同步语句块,所以可能等待MayWait,然后调用startActivityLocked
ActivityStackSupervisor.java-&gt;startActivityLocked()
ActivityStackSupervisor.java-&gt;startActivityUncheckedLocked()

ActivityStack.java-&gt;startActivityLocked()

ActivityStackSupervisor.java-&gt;resumeTopActivitiesLocked()

ActivityStack.java-&gt;resumeTopActivityLocked()
ActivityStack.java-&gt;resumeTopActivityInnerLocked()

ActivityStackSupervisor.java-&gt;startSpecificActivityLocked()

ActivityManagerService.java-&gt;startProcessLocked();

android.os.Process.java-&gt;start()-&gt;startViaZygote()
android.os.Process.java-&gt;zygoteSendArgsAndGetResult()
</code></pre><p>   通过Zygote孵化了一个ActivityThread,去查看ActivityThread的main方法,转到ActivityThread-main</p>
<pre><code>android.app.ActivityThread.java-&gt;main()
android.app.ActivityThread.java-&gt;attach()

ActivityManagerService.java-&gt;attachApplication()

ActivityStackSupervisor.java-&gt;attachApplicationLocked()
ActivityStackSupervisor.java-&gt;realStartActivityLocked()

ActivityThread.java-&gt;scheduleLaunchActivity()
ActivityThread.java-&gt;handleLaunchActivity()
ActivityThread.java-&gt;performLaunchActivity()

Instrumentation-&gt;callActivityOnCreate()

Activity-&gt;performCreate()
</code></pre><p>   走到这里就执行了onCreate();</p>
<p>com.android.server.am.ActivityStackSupervisor.java<br>android.app.Instrumentation.java<br>com.android.server.am.ActivityManagerService.java<br>com.android.server.am.ActivityStack.java<br>android.app.ActivityThread.java</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/16/activity启动/" data-id="cjcubibtl0011gjs647nb7yom" class="article-share-link">Compartir</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/startActivity/">startActivity</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Previo</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AFNetworking/">AFNetworking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityInfo/">ActivityInfo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityManagerNative-getDefault/">ActivityManagerNative-getDefault</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityManagerService-attachApplication/">ActivityManagerService-attachApplication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityManagerService-startActivity/">ActivityManagerService-startActivity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityManagerService-startProcessLocked/">ActivityManagerService-startProcessLocked</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityStack-resumeTopActivityLocked/">ActivityStack-resumeTopActivityLocked</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityStack-startActivityLocked/">ActivityStack-startActivityLocked</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityStackSupervisor-attachApplicationLocked/">ActivityStackSupervisor-attachApplicationLocked</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityStackSupervisor-resolveActivity/">ActivityStackSupervisor-resolveActivity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityStackSupervisor-resumeTopActivitiesLocked/">ActivityStackSupervisor-resumeTopActivitiesLocked</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityStackSupervisor-startActivityMayWait/">ActivityStackSupervisor-startActivityMayWait</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityStackSupervisor-startSpecificActivityLocked/">ActivityStackSupervisor-startSpecificActivityLocked</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityStarter-startActivityMayWait/">ActivityStarter-startActivityMayWait</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityThread-main/">ActivityThread-main</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActivityThread-scheduleLaunchActivity/">ActivityThread-scheduleLaunchActivity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Instrumentation-callActivityOnCreate/">Instrumentation.callActivityOnCreate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Launcher/">Launcher</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MBProgressHUD/">MBProgressHUD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OC/">OC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Process-start/">Process-start</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UIAlertController/">UIAlertController</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UILabel/">UILabel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/startActivity/">startActivity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/权限测试/">权限测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nube de Tags</h3>
    <div class="widget tagcloud">
      <a href="/tags/AFNetworking/" style="font-size: 10px;">AFNetworking</a> <a href="/tags/ActivityInfo/" style="font-size: 13.33px;">ActivityInfo</a> <a href="/tags/ActivityManagerNative-getDefault/" style="font-size: 13.33px;">ActivityManagerNative-getDefault</a> <a href="/tags/ActivityManagerService-attachApplication/" style="font-size: 13.33px;">ActivityManagerService-attachApplication</a> <a href="/tags/ActivityManagerService-startActivity/" style="font-size: 13.33px;">ActivityManagerService-startActivity</a> <a href="/tags/ActivityManagerService-startProcessLocked/" style="font-size: 13.33px;">ActivityManagerService-startProcessLocked</a> <a href="/tags/ActivityStack-resumeTopActivityLocked/" style="font-size: 13.33px;">ActivityStack-resumeTopActivityLocked</a> <a href="/tags/ActivityStack-startActivityLocked/" style="font-size: 13.33px;">ActivityStack-startActivityLocked</a> <a href="/tags/ActivityStackSupervisor-attachApplicationLocked/" style="font-size: 13.33px;">ActivityStackSupervisor-attachApplicationLocked</a> <a href="/tags/ActivityStackSupervisor-resolveActivity/" style="font-size: 13.33px;">ActivityStackSupervisor-resolveActivity</a> <a href="/tags/ActivityStackSupervisor-resumeTopActivitiesLocked/" style="font-size: 13.33px;">ActivityStackSupervisor-resumeTopActivitiesLocked</a> <a href="/tags/ActivityStackSupervisor-startActivityMayWait/" style="font-size: 16.67px;">ActivityStackSupervisor-startActivityMayWait</a> <a href="/tags/ActivityStackSupervisor-startSpecificActivityLocked/" style="font-size: 13.33px;">ActivityStackSupervisor-startSpecificActivityLocked</a> <a href="/tags/ActivityStarter-startActivityMayWait/" style="font-size: 13.33px;">ActivityStarter-startActivityMayWait</a> <a href="/tags/ActivityThread-main/" style="font-size: 13.33px;">ActivityThread-main</a> <a href="/tags/ActivityThread-scheduleLaunchActivity/" style="font-size: 13.33px;">ActivityThread-scheduleLaunchActivity</a> <a href="/tags/Instrumentation-callActivityOnCreate/" style="font-size: 13.33px;">Instrumentation.callActivityOnCreate</a> <a href="/tags/Launcher/" style="font-size: 10px;">Launcher</a> <a href="/tags/MBProgressHUD/" style="font-size: 10px;">MBProgressHUD</a> <a href="/tags/OC/" style="font-size: 16.67px;">OC</a> <a href="/tags/Process-start/" style="font-size: 13.33px;">Process-start</a> <a href="/tags/UIAlertController/" style="font-size: 10px;">UIAlertController</a> <a href="/tags/UILabel/" style="font-size: 10px;">UILabel</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/startActivity/" style="font-size: 10px;">startActivity</a> <a href="/tags/权限测试/" style="font-size: 10px;">权限测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivos</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Posts recientes</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/25/OC-AFN使用/">OC-AFN使用</a>
          </li>
        
          <li>
            <a href="/2018/01/25/OC-MBProgressHUD使用/">OC-MBProgressHUD使用</a>
          </li>
        
          <li>
            <a href="/2018/01/25/OC-对话框/">OC-对话框</a>
          </li>
        
          <li>
            <a href="/2018/01/25/OC-UILabel点击事件/">OC-UILabel点击事件</a>
          </li>
        
          <li>
            <a href="/2018/01/22/launcher-启动Main/">launcher 启动Main</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 zhushuhao<br>
      Construido por <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>