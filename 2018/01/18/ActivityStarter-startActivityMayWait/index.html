<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>ActivityStarter-startActivityMayWait | 生死如风，常伴吾身</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="###源码位置com.android.server.am.ActivityStarter.java class ActivityStarter {} 这个类没有继承别的类，也没有实现任何接口 这个类的定义如下： /**  * Controller for interpreting how and then launching activities.  *  * This class collect">
<meta name="keywords" content="android ActivityStarter-startActivityMayWait">
<meta property="og:type" content="article">
<meta property="og:title" content="ActivityStarter-startActivityMayWait">
<meta property="og:url" content="http://yoursite.com/2018/01/18/ActivityStarter-startActivityMayWait/index.html">
<meta property="og:site_name" content="生死如风，常伴吾身">
<meta property="og:description" content="###源码位置com.android.server.am.ActivityStarter.java class ActivityStarter {} 这个类没有继承别的类，也没有实现任何接口 这个类的定义如下： /**  * Controller for interpreting how and then launching activities.  *  * This class collect">
<meta property="og:updated_time" content="2018-01-18T03:09:59.085Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ActivityStarter-startActivityMayWait">
<meta name="twitter:description" content="###源码位置com.android.server.am.ActivityStarter.java class ActivityStarter {} 这个类没有继承别的类，也没有实现任何接口 这个类的定义如下： /**  * Controller for interpreting how and then launching activities.  *  * This class collect">
  
    <link rel="alternate" href="/atom.xml" title="生死如风，常伴吾身" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">生死如风，常伴吾身</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ActivityStarter-startActivityMayWait" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/18/ActivityStarter-startActivityMayWait/" class="article-date">
  <time datetime="2018-01-18T02:49:14.000Z" itemprop="datePublished">2018-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ActivityStarter-startActivityMayWait
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###源码位置com.android.server.am.ActivityStarter.java</p>
<pre><code>class ActivityStarter {}
这个类没有继承别的类，也没有实现任何接口
这个类的定义如下：
/**
 * Controller for interpreting how and then launching activities.
 *
 * This class collects all the logic for determining how an intent and flags should be turned into
 * an activity and associated task and stack.
 */
 解释如何发布活动的控制器。
 这个类收集所有逻辑，以确定如何根据intent和flags转换为一个对应的Activity，并且和堆栈关联在一起。
 大致是个帮助类。
</code></pre><p>  查看startActivityMayWait方法，这是个很长的方法，需要很大的勇气。</p>
<pre><code>final int startActivityMayWait(IApplicationThread caller, int callingUid,
          String callingPackage, Intent intent, String resolvedType,
          IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
          IBinder resultTo, String resultWho, int requestCode, int startFlags,
          ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,
          Bundle bOptions, boolean ignoreTargetSecurity, int userId,
          IActivityContainer iContainer, TaskRecord inTask) {

      // Refuse possible leaked file descriptors
      //拒绝可能泄露的文件描述符
      if (intent != null &amp;&amp; intent.hasFileDescriptors()) {
          throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);
      }
      mSupervisor.mActivityMetricsLogger.notifyActivityLaunching();
      boolean componentSpecified = intent.getComponent() != null;

      // Save a copy in case ephemeral needs it
      //保存一个副本以备临时需要
      final Intent ephemeralIntent = new Intent(intent);
      // Don&apos;t modify the client&apos;s object!
      //不要修改客户端的对象！
      intent = new Intent(intent);

      ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);
      if (rInfo == null) {
          UserInfo userInfo = mSupervisor.getUserInfo(userId);
          if (userInfo != null &amp;&amp; userInfo.isManagedProfile()) {
              // Special case for managed profiles, if attempting to launch non-cryto aware
              // app in a locked managed profile from an unlocked parent allow it to resolve
              // as user will be sent via confirm credentials to unlock the profile.
              UserManager userManager = UserManager.get(mService.mContext);
              boolean profileLockedAndParentUnlockingOrUnlocked = false;
              long token = Binder.clearCallingIdentity();
              try {
                  UserInfo parent = userManager.getProfileParent(userId);
                  profileLockedAndParentUnlockingOrUnlocked = (parent != null)
                          &amp;&amp; userManager.isUserUnlockingOrUnlocked(parent.id)
                          &amp;&amp; !userManager.isUserUnlockingOrUnlocked(userId);
              } finally {
                  Binder.restoreCallingIdentity(token);
              }
              if (profileLockedAndParentUnlockingOrUnlocked) {
                  rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,
                          PackageManager.MATCH_DIRECT_BOOT_AWARE
                                  | PackageManager.MATCH_DIRECT_BOOT_UNAWARE);
              }
          }
      }
      // Collect information about the target of the Intent.
      //收集intent有关的信息
      ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);

      ActivityOptions options = ActivityOptions.fromBundle(bOptions);
      ActivityStackSupervisor.ActivityContainer container =
              (ActivityStackSupervisor.ActivityContainer)iContainer;
      synchronized (mService) {
          if (container != null &amp;&amp; container.mParentActivity != null &amp;&amp;
                  container.mParentActivity.state != RESUMED) {
              // Cannot start a child activity if the parent is not resumed.
              return ActivityManager.START_CANCELED;
          }
          final int realCallingPid = Binder.getCallingPid();
          final int realCallingUid = Binder.getCallingUid();
          int callingPid;
          if (callingUid &gt;= 0) {
              callingPid = -1;
          } else if (caller == null) {
              callingPid = realCallingPid;
              callingUid = realCallingUid;
          } else {
              callingPid = callingUid = -1;
          }

          final ActivityStack stack;
          if (container == null || container.mStack.isOnHomeDisplay()) {
              stack = mSupervisor.mFocusedStack;
          } else {
              stack = container.mStack;
          }
          stack.mConfigWillChange = config != null &amp;&amp; mService.mConfiguration.diff(config) != 0;
          if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,
                  &quot;Starting activity when config will change = &quot; + stack.mConfigWillChange);

          final long origId = Binder.clearCallingIdentity();

          if (aInfo != null &amp;&amp;
                  (aInfo.applicationInfo.privateFlags
                          &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) {
              // This may be a heavy-weight process!  Check to see if we already
              // have another, different heavy-weight process running.
              if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) {
                  final ProcessRecord heavy = mService.mHeavyWeightProcess;
                  if (heavy != null &amp;&amp; (heavy.info.uid != aInfo.applicationInfo.uid
                          || !heavy.processName.equals(aInfo.processName))) {
                      int appCallingUid = callingUid;
                      if (caller != null) {
                          ProcessRecord callerApp = mService.getRecordForAppLocked(caller);
                          if (callerApp != null) {
                              appCallingUid = callerApp.info.uid;
                          } else {
                              Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller
                                      + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;
                                      + intent.toString());
                              ActivityOptions.abort(options);
                              return ActivityManager.START_PERMISSION_DENIED;
                          }
                      }

                      IIntentSender target = mService.getIntentSenderLocked(
                              ActivityManager.INTENT_SENDER_ACTIVITY, &quot;android&quot;,
                              appCallingUid, userId, null, null, 0, new Intent[] { intent },
                              new String[] { resolvedType }, PendingIntent.FLAG_CANCEL_CURRENT
                                      | PendingIntent.FLAG_ONE_SHOT, null);

                      Intent newIntent = new Intent();
                      if (requestCode &gt;= 0) {
                          // Caller is requesting a result.
                          newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT, true);
                      }
                      newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT,
                              new IntentSender(target));
                      if (heavy.activities.size() &gt; 0) {
                          ActivityRecord hist = heavy.activities.get(0);
                          newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP,
                                  hist.packageName);
                          newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK,
                                  hist.task.taskId);
                      }
                      newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP,
                              aInfo.packageName);
                      newIntent.setFlags(intent.getFlags());
                      newIntent.setClassName(&quot;android&quot;,
                              HeavyWeightSwitcherActivity.class.getName());
                      intent = newIntent;
                      resolvedType = null;
                      caller = null;
                      callingUid = Binder.getCallingUid();
                      callingPid = Binder.getCallingPid();
                      componentSpecified = true;
                      rInfo = mSupervisor.resolveIntent(intent, null /*resolvedType*/, userId);
                      aInfo = rInfo != null ? rInfo.activityInfo : null;
                      if (aInfo != null) {
                          aInfo = mService.getActivityInfoForUser(aInfo, userId);
                      }
                  }
              }
          }

          final ActivityRecord[] outRecord = new ActivityRecord[1];

          //重点看这里
          int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,
                  aInfo, rInfo, voiceSession, voiceInteractor,
                  resultTo, resultWho, requestCode, callingPid,
                  callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                  options, ignoreTargetSecurity, componentSpecified, outRecord, container,
                  inTask);

          Binder.restoreCallingIdentity(origId);

          if (stack.mConfigWillChange) {
              // If the caller also wants to switch to a new configuration,
              // do so now.  This allows a clean switch, as we are waiting
              // for the current activity to pause (so we will not destroy
              // it), and have not yet started the next activity.
              mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,
                      &quot;updateConfiguration()&quot;);
              stack.mConfigWillChange = false;
              if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,
                      &quot;Updating to new configuration after starting activity.&quot;);
              mService.updateConfigurationLocked(config, null, false);
          }

          if (outResult != null) {
              outResult.result = res;
              if (res == ActivityManager.START_SUCCESS) {
                  mSupervisor.mWaitingActivityLaunched.add(outResult);
                  do {
                      try {
                          mService.wait();
                      } catch (InterruptedException e) {
                      }
                  } while (outResult.result != START_TASK_TO_FRONT
                          &amp;&amp; !outResult.timeout &amp;&amp; outResult.who == null);
                  if (outResult.result == START_TASK_TO_FRONT) {
                      res = START_TASK_TO_FRONT;
                  }
              }
              if (res == START_TASK_TO_FRONT) {
                  ActivityRecord r = stack.topRunningActivityLocked();
                  if (r.nowVisible &amp;&amp; r.state == RESUMED) {
                      outResult.timeout = false;
                      outResult.who = new ComponentName(r.info.packageName, r.info.name);
                      outResult.totalTime = 0;
                      outResult.thisTime = 0;
                  } else {
                      outResult.thisTime = SystemClock.uptimeMillis();
                      mSupervisor.mWaitingActivityVisible.add(outResult);
                      do {
                          try {
                              mService.wait();
                          } catch (InterruptedException e) {
                          }
                      } while (!outResult.timeout &amp;&amp; outResult.who == null);
                  }
              }
          }

          final ActivityRecord launchedActivity = mReusedActivity != null
                  ? mReusedActivity : outRecord[0];
          mSupervisor.mActivityMetricsLogger.notifyActivityLaunched(res, launchedActivity);
          return res;
      }
  }
</code></pre><p>  重点</p>
<pre><code>int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,
                      aInfo, rInfo, voiceSession, voiceInteractor,
                      resultTo, resultWho, requestCode, callingPid,
                      callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                      options, ignoreTargetSecurity, componentSpecified, outRecord, container,
                      inTask);

转到startActivityLocked方法
</code></pre><p>  查看startActivityLocked方法</p>
<pre><code>final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
          String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
          IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
          IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
          String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
          ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
          ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,
          TaskRecord inTask) {
      int err = ActivityManager.START_SUCCESS;

      ProcessRecord callerApp = null;
      if (caller != null) {
          callerApp = mService.getRecordForAppLocked(caller);
          if (callerApp != null) {
              callingPid = callerApp.pid;
              callingUid = callerApp.info.uid;
          } else {
              Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller
                      + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;
                      + intent.toString());
              err = ActivityManager.START_PERMISSION_DENIED;
          }
      }

      final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;

      if (err == ActivityManager.START_SUCCESS) {
          Slog.i(TAG, &quot;START u&quot; + userId + &quot; {&quot; + intent.toShortString(true, true, true, false)
                  + &quot;} from uid &quot; + callingUid
                  + &quot; on display &quot; + (container == null ? (mSupervisor.mFocusedStack == null ?
                  Display.DEFAULT_DISPLAY : mSupervisor.mFocusedStack.mDisplayId) :
                  (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY :
                          container.mActivityDisplay.mDisplayId)));
      }

      ActivityRecord sourceRecord = null;
      ActivityRecord resultRecord = null;
      if (resultTo != null) {
          sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);
          if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,
                  &quot;Will send result to &quot; + resultTo + &quot; &quot; + sourceRecord);
          if (sourceRecord != null) {
              if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) {
                  resultRecord = sourceRecord;
              }
          }
      }

      final int launchFlags = intent.getFlags();

      if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) {
          // Transfer the result target from the source activity to the new
          // one being started, including any failures.
          if (requestCode &gt;= 0) {
              ActivityOptions.abort(options);
              return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
          }
          resultRecord = sourceRecord.resultTo;
          if (resultRecord != null &amp;&amp; !resultRecord.isInStackLocked()) {
              resultRecord = null;
          }
          resultWho = sourceRecord.resultWho;
          requestCode = sourceRecord.requestCode;
          sourceRecord.resultTo = null;
          if (resultRecord != null) {
              resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);
          }
          if (sourceRecord.launchedFromUid == callingUid) {
              // The new activity is being launched from the same uid as the previous
              // activity in the flow, and asking to forward its result back to the
              // previous.  In this case the activity is serving as a trampoline between
              // the two, so we also want to update its launchedFromPackage to be the
              // same as the previous activity.  Note that this is safe, since we know
              // these two packages come from the same uid; the caller could just as
              // well have supplied that same package name itself.  This specifially
              // deals with the case of an intent picker/chooser being launched in the app
              // flow to redirect to an activity picked by the user, where we want the final
              // activity to consider it to have been launched by the previous app activity.
              callingPackage = sourceRecord.launchedFromPackage;
          }
      }

      if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) {
          // We couldn&apos;t find a class that can handle the given Intent.
          // That&apos;s the end of that!
          err = ActivityManager.START_INTENT_NOT_RESOLVED;
      }

      if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) {
          // We couldn&apos;t find the specific class specified in the Intent.
          // Also the end of the line.
          err = ActivityManager.START_CLASS_NOT_FOUND;
      }

      if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null
              &amp;&amp; sourceRecord.task.voiceSession != null) {
          // If this activity is being launched as part of a voice session, we need
          // to ensure that it is safe to do so.  If the upcoming activity will also
          // be part of the voice session, we can only launch it if it has explicitly
          // said it supports the VOICE category, or it is a part of the calling app.
          if ((launchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == 0
                  &amp;&amp; sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) {
              try {
                  intent.addCategory(Intent.CATEGORY_VOICE);
                  if (!AppGlobals.getPackageManager().activitySupportsIntent(
                          intent.getComponent(), intent, resolvedType)) {
                      Slog.w(TAG,
                              &quot;Activity being started in current voice task does not support voice: &quot;
                                      + intent);
                      err = ActivityManager.START_NOT_VOICE_COMPATIBLE;
                  }
              } catch (RemoteException e) {
                  Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);
                  err = ActivityManager.START_NOT_VOICE_COMPATIBLE;
              }
          }
      }

      if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) {
          // If the caller is starting a new voice session, just make sure the target
          // is actually allowing it to run this way.
          try {
              if (!AppGlobals.getPackageManager().activitySupportsIntent(intent.getComponent(),
                      intent, resolvedType)) {
                  Slog.w(TAG,
                          &quot;Activity being started in new voice task does not support: &quot;
                                  + intent);
                  err = ActivityManager.START_NOT_VOICE_COMPATIBLE;
              }
          } catch (RemoteException e) {
              Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);
              err = ActivityManager.START_NOT_VOICE_COMPATIBLE;
          }
      }

      final ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack;

      if (err != START_SUCCESS) {
          if (resultRecord != null) {
              resultStack.sendActivityResultLocked(
                      -1, resultRecord, resultWho, requestCode, RESULT_CANCELED, null);
          }
          ActivityOptions.abort(options);
          return err;
      }

      boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,
              requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity, callerApp,
              resultRecord, resultStack, options);
      abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,
              callingPid, resolvedType, aInfo.applicationInfo);

      if (mService.mController != null) {
          try {
              // The Intent we give to the watcher has the extra data
              // stripped off, since it can contain private information.
              Intent watchIntent = intent.cloneFilter();
              abort |= !mService.mController.activityStarting(watchIntent,
                      aInfo.applicationInfo.packageName);
          } catch (RemoteException e) {
              mService.mController = null;
          }
      }

      mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage);
      mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid, callingUid,
              options);
      intent = mInterceptor.mIntent;
      rInfo = mInterceptor.mRInfo;
      aInfo = mInterceptor.mAInfo;
      resolvedType = mInterceptor.mResolvedType;
      inTask = mInterceptor.mInTask;
      callingPid = mInterceptor.mCallingPid;
      callingUid = mInterceptor.mCallingUid;
      options = mInterceptor.mActivityOptions;
      if (abort) {
          if (resultRecord != null) {
              resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode,
                      RESULT_CANCELED, null);
          }
          // We pretend to the caller that it was really started, but
          // they will just get a cancel result.
          ActivityOptions.abort(options);
          return START_SUCCESS;
      }

      // If permissions need a review before any of the app components can run, we
      // launch the review activity and pass a pending intent to start the activity
      // we are to launching now after the review is completed.
      if (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; aInfo != null) {
          if (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired(
                  aInfo.packageName, userId)) {
              IIntentSender target = mService.getIntentSenderLocked(
                      ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage,
                      callingUid, userId, null, null, 0, new Intent[]{intent},
                      new String[]{resolvedType}, PendingIntent.FLAG_CANCEL_CURRENT
                              | PendingIntent.FLAG_ONE_SHOT, null);

              final int flags = intent.getFlags();
              Intent newIntent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS);
              newIntent.setFlags(flags
                      | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
              newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName);
              newIntent.putExtra(Intent.EXTRA_INTENT, new IntentSender(target));
              if (resultRecord != null) {
                  newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, true);
              }
              intent = newIntent;

              resolvedType = null;
              callingUid = realCallingUid;
              callingPid = realCallingPid;

              rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);
              aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags,
                      null /*profilerInfo*/);

              if (DEBUG_PERMISSIONS_REVIEW) {
                  Slog.i(TAG, &quot;START u&quot; + userId + &quot; {&quot; + intent.toShortString(true, true,
                          true, false) + &quot;} from uid &quot; + callingUid + &quot; on display &quot;
                          + (container == null ? (mSupervisor.mFocusedStack == null ?
                          Display.DEFAULT_DISPLAY : mSupervisor.mFocusedStack.mDisplayId) :
                          (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY :
                                  container.mActivityDisplay.mDisplayId)));
              }
          }
      }

      // If we have an ephemeral app, abort the process of launching the resolved intent.
      // Instead, launch the ephemeral installer. Once the installer is finished, it
      // starts either the intent we resolved here [on install error] or the ephemeral
      // app [on install success].
      if (rInfo != null &amp;&amp; rInfo.ephemeralResolveInfo != null) {
          intent = buildEphemeralInstallerIntent(intent, ephemeralIntent,
                  rInfo.ephemeralResolveInfo.getPackageName(), callingPackage, resolvedType,
                  userId);
          resolvedType = null;
          callingUid = realCallingUid;
          callingPid = realCallingPid;

          aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, null /*profilerInfo*/);
      }

      ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,
              intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,
              requestCode, componentSpecified, voiceSession != null, mSupervisor, container,
              options, sourceRecord);
      if (outActivity != null) {
          outActivity[0] = r;
      }

      if (r.appTimeTracker == null &amp;&amp; sourceRecord != null) {
          // If the caller didn&apos;t specify an explicit time tracker, we want to continue
          // tracking under any it has.
          r.appTimeTracker = sourceRecord.appTimeTracker;
      }

      final ActivityStack stack = mSupervisor.mFocusedStack;
      if (voiceSession == null &amp;&amp; (stack.mResumedActivity == null
              || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) {
          if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,
                  realCallingPid, realCallingUid, &quot;Activity start&quot;)) {
              PendingActivityLaunch pal =  new PendingActivityLaunch(r,
                      sourceRecord, startFlags, stack, callerApp);
              mPendingActivityLaunches.add(pal);
              ActivityOptions.abort(options);
              return ActivityManager.START_SWITCHES_CANCELED;
          }
      }

      if (mService.mDidAppSwitch) {
          // This is the second allowed switch since we stopped switches,
          // so now just generally allow switches.  Use case: user presses
          // home (switches disabled, switch to home, mDidAppSwitch now true);
          // user taps a home icon (coming from home so allowed, we hit here
          // and now allow anyone to switch again).
          mService.mAppSwitchesAllowedTime = 0;
      } else {
          mService.mDidAppSwitch = true;
      }

      doPendingActivityLaunchesLocked(false);

      try {
          mService.mWindowManager.deferSurfaceLayout();
          err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,
                  true, options, inTask);
      } finally {
          mService.mWindowManager.continueSurfaceLayout();
      }
      postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack);
      return err;
  }
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/18/ActivityStarter-startActivityMayWait/" data-id="cjck3qur0000pc5s6yqkc0dy0" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android-ActivityStarter-startActivityMayWait/">android ActivityStarter-startActivityMayWait</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/01/18/ActivityStackSupervisor-startActivityMayWait/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          ActivityStackSupervisor-startActivityMayWait
        
      </div>
    </a>
  
  
    <a href="/2018/01/18/ActivityManagerService-startActivity/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">ActivityManagerService-startActivity</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityManagerNative-getDefault/">android ActivityManagerNative-getDefault</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityManagerNative-getDefault-ActivityManagerService-startActivity/">android ActivityManagerNative-getDefault ActivityManagerService-startActivity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityManagerService-attachApplication-ActivityStackSupervisor-attachApplicationLocked/">android ActivityManagerService-attachApplication ActivityStackSupervisor-attachApplicationLocked</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityManagerService-startActivity-ActivityStarter-startActivityMayWait-ActivityStackSupervisor-startActivityMayWait/">android ActivityManagerService-startActivity ActivityStarter-startActivityMayWait ActivityStackSupervisor-startActivityMayWait</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityManagerService-startProcessLocked-Process-start/">android ActivityManagerService-startProcessLocked Process-start</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityStack-resumeTopActivityLocked-ActivityStackSupervisor-startSpecificActivityLocked/">android ActivityStack-resumeTopActivityLocked ActivityStackSupervisor-startSpecificActivityLocked</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityStack-startActivityLocked-ActivityStackSupervisor-resumeTopActivitiesLocked/">android ActivityStack-startActivityLocked ActivityStackSupervisor-resumeTopActivitiesLocked</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityStackSupervisor-attachApplicationLocked-ActivityThread-scheduleLaunchActivity/">android ActivityStackSupervisor-attachApplicationLocked ActivityThread-scheduleLaunchActivity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityStackSupervisor-resumeTopActivitiesLocked-ActivityStack-resumeTopActivityLocked/">android ActivityStackSupervisor-resumeTopActivitiesLocked ActivityStack-resumeTopActivityLocked</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityStackSupervisor-startActivityMayWait-ActivityStack-startActivityLocked/">android ActivityStackSupervisor-startActivityMayWait ActivityStack-startActivityLocked</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityStackSupervisor-startSpecificActivityLocked-ActivityManagerService-startProcessLocked/">android ActivityStackSupervisor-startSpecificActivityLocked ActivityManagerService-startProcessLocked</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityStarter-startActivityMayWait/">android ActivityStarter-startActivityMayWait</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityThread-main-ActivityManagerService-attachApplication/">android ActivityThread-main ActivityManagerService-attachApplication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ActivityThread-scheduleLaunchActivity/">android ActivityThread-scheduleLaunchActivity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-Process-start-ActivityThread-main/">android Process-start ActivityThread-main</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/android-ActivityManagerNative-getDefault/" style="font-size: 10px;">android ActivityManagerNative-getDefault</a> <a href="/tags/android-ActivityManagerNative-getDefault-ActivityManagerService-startActivity/" style="font-size: 10px;">android ActivityManagerNative-getDefault ActivityManagerService-startActivity</a> <a href="/tags/android-ActivityManagerService-attachApplication-ActivityStackSupervisor-attachApplicationLocked/" style="font-size: 10px;">android ActivityManagerService-attachApplication ActivityStackSupervisor-attachApplicationLocked</a> <a href="/tags/android-ActivityManagerService-startActivity-ActivityStarter-startActivityMayWait-ActivityStackSupervisor-startActivityMayWait/" style="font-size: 10px;">android ActivityManagerService-startActivity ActivityStarter-startActivityMayWait ActivityStackSupervisor-startActivityMayWait</a> <a href="/tags/android-ActivityManagerService-startProcessLocked-Process-start/" style="font-size: 10px;">android ActivityManagerService-startProcessLocked Process-start</a> <a href="/tags/android-ActivityStack-resumeTopActivityLocked-ActivityStackSupervisor-startSpecificActivityLocked/" style="font-size: 10px;">android ActivityStack-resumeTopActivityLocked ActivityStackSupervisor-startSpecificActivityLocked</a> <a href="/tags/android-ActivityStack-startActivityLocked-ActivityStackSupervisor-resumeTopActivitiesLocked/" style="font-size: 10px;">android ActivityStack-startActivityLocked ActivityStackSupervisor-resumeTopActivitiesLocked</a> <a href="/tags/android-ActivityStackSupervisor-attachApplicationLocked-ActivityThread-scheduleLaunchActivity/" style="font-size: 10px;">android ActivityStackSupervisor-attachApplicationLocked ActivityThread-scheduleLaunchActivity</a> <a href="/tags/android-ActivityStackSupervisor-resumeTopActivitiesLocked-ActivityStack-resumeTopActivityLocked/" style="font-size: 10px;">android ActivityStackSupervisor-resumeTopActivitiesLocked ActivityStack-resumeTopActivityLocked</a> <a href="/tags/android-ActivityStackSupervisor-startActivityMayWait-ActivityStack-startActivityLocked/" style="font-size: 10px;">android ActivityStackSupervisor-startActivityMayWait ActivityStack-startActivityLocked</a> <a href="/tags/android-ActivityStackSupervisor-startSpecificActivityLocked-ActivityManagerService-startProcessLocked/" style="font-size: 10px;">android ActivityStackSupervisor-startSpecificActivityLocked ActivityManagerService-startProcessLocked</a> <a href="/tags/android-ActivityStarter-startActivityMayWait/" style="font-size: 10px;">android ActivityStarter-startActivityMayWait</a> <a href="/tags/android-ActivityThread-main-ActivityManagerService-attachApplication/" style="font-size: 10px;">android ActivityThread-main ActivityManagerService-attachApplication</a> <a href="/tags/android-ActivityThread-scheduleLaunchActivity/" style="font-size: 10px;">android ActivityThread-scheduleLaunchActivity</a> <a href="/tags/android-Process-start-ActivityThread-main/" style="font-size: 10px;">android Process-start ActivityThread-main</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/18/ActivityThread-scheduleLaunchActivity/">ActivityThread-scheduleLaunchActivity </a>
          </li>
        
          <li>
            <a href="/2018/01/18/ActivityStackSupervisor-attachApplicationLocked/">ActivityStackSupervisor-attachApplicationLocked</a>
          </li>
        
          <li>
            <a href="/2018/01/18/ActivityManagerService-attachApplication/">ActivityManagerService-attachApplication</a>
          </li>
        
          <li>
            <a href="/2018/01/18/ActivityThread-main/">ActivityThread-main</a>
          </li>
        
          <li>
            <a href="/2018/01/18/Process-start/">Process-start</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 zhushuhao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>